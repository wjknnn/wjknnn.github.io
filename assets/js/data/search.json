[ { "title": "[Javascript] Optional chaining", "url": "/posts/Javascript-optionalChaining/", "categories": "Language, Javascript", "tags": "Javascript, Optional chaining", "date": "2023-12-16 23:35:00 +0900", "snippet": "Optional chaining 문법은 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있게 해준다.사용 이유아래의 코드를 보자. user객체의 street값을 콘솔에 출력하려 한다.그렇다면 출력 코드를 아래와 같이 짜게 될 것이다.let user = { name: \"John\", age: 18, address: { street: ...", "content": "Optional chaining 문법은 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있게 해준다.사용 이유아래의 코드를 보자. user객체의 street값을 콘솔에 출력하려 한다.그렇다면 출력 코드를 아래와 같이 짜게 될 것이다.let user = { name: \"John\", age: 18, address: { street: \"AwesomeLoad\" }};console.log(user.address.street);// AwesomeLoad그럼 만약 아래와 같은 상활일 때 street을 출력하면 어떻게 될까?let user = {};console.log(user.address.street);// TypeError: Cannot read property 'street' of undefined당연하게도 출력하려고 참조하는 값들이 모두 undefined 이기 때문에 오류가 발생하게 된다.그럴 때 우리가 사용하던 것이 바로 &amp;&amp; 연산자이다.console.log(user &amp;&amp; user.address &amp;&amp; user.address.street);// undefined (에러가 발생하지 않음)이렇게 AND 연산자를 이용해서 사용하면 에러를 예방할 수 있지만,코드가 매우 길어질 수 있다는 단점이 있다.그렇게 해서 나오게 된것이 옵셔널 체이닝(Optional chaining)이라는 문법이다.사용 방법사용방법은 간단하다. 일단 옵셔널 체이닝의 기본적인 구조는 ?. 이다.?. 은 앞의 대상이 undefined나 null이면 확인을 멈추고 undefined를 반환한다.즉, ?. 앞의 대상의 값이 있을 수도 있고 없을 수도 있을 때 undefined를 반환한다고 보면 된다.let user = {};console.log(user?.address?.street);//undefinfed이제 아까와 같은 동작의 코드를 쓰면AND 연산자를 사용했을 때보다 더 짧은 코드로 평가할 수 있게 되었다. 옵셔널 체이닝을 남용해서는 안된다.꼭 있어야 하는데 없는 경우에 ?. 을 사용하면 디버깅이 어려워지니, 지양하도록 하자.그러니 꼭 존재하지 않아도 괜찮은 대상에만 사용하는 것이 바람직한 방법이다. ?. 앞의 변수는 꼭 선언되어 있어야 한다.user?.address를 사용하려면 let이나 const로 user를 정의 해줘야 한다.이렇게 옵셔널 체이닝은 선언이 완료된 변수를 대상으로만 작동한다.?. 은 왼쪽 평가 대상에 값이 없으면 즉시 평가를 멈춘다.이런 평가 방법을 단락 평가라고 한다.그렇기 때문에 함수 호출과 같은 ?. 오른쪽에 있는 부가 동작들은 평가가 멈췄을때, 작동을 하지 않게 된다.그리고 ?. 은 함수 호출을 하는 경우에 이 ?.() 과,대괄호를 사용한 객체 프로퍼티 접근에 이 ?.[] 을 쓴다.마지막으로, ?. 은 아래 코드와 같이 읽거나 삭제는 가능하지만, 쓰기에는 사용이 불가능하다.let user = { name: \"John\", age: 18, address: { street: \"AwesomeLoad\" }};console.log(user?.address.street);delete user?.address.street;user?.name = \"Wick\";불가능한 이유는, user?.name이 undefined일 수도 있다는 것이 ?. 을 붙임으로써나타났기 때문에, undeifined = “Wick”; 꼴이 되어 에러가 나는 것 같다.에러 없이 저 조건 그대로 할당하고 싶으면 아래 코드를 쓰면 될 것 같다.if (user !== undefined) { user.name = \"Wick\";}" }, { "title": "[Javascript] this", "url": "/posts/Javascript-this/", "categories": "Language, Javascript", "tags": "Javascript, this", "date": "2023-12-15 19:57:00 +0900", "snippet": "js에서의 this가 상황에 따라서 어떤 값을 가지는지 가끔 헷갈리는 경우가 종종 있다.하지만 알고보면 꽤 간단하다.this는 다음과 같은 규칙을 따른다.1. new 바인딩만약 함수를 호출할 때 new키워드를 사용한다면, 함수 내부에 있는 this는 완전히 새로운 객체를 반환해 준다.function constructorExample() { this....", "content": "js에서의 this가 상황에 따라서 어떤 값을 가지는지 가끔 헷갈리는 경우가 종종 있다.하지만 알고보면 꽤 간단하다.this는 다음과 같은 규칙을 따른다.1. new 바인딩만약 함수를 호출할 때 new키워드를 사용한다면, 함수 내부에 있는 this는 완전히 새로운 객체를 반환해 준다.function constructorExample() { this.value = 10; console.log(this);}new constructorExample();// output : { value: 10 }2. 명시적 바인딩만약 함수를 호출할 때 apply나 call 또는 bind를 사용한다면, 함수 내부의 this는 인수로 전달된 객체를 반환해 준다.function fn() { console.log(this);}const obj = { value: 5};const boundFn = fn.bind(obj);boundFn(); // output : { value: 5 }fn.call(obj); // output : { value: 5 }fn.apply(obj); // output : { value: 5 }3. 암시적 바인딩만약 객체 안의 함수를 메서드로 호출한다면, this는 함수가 포함된 객체를 반환해 준다.const obj = { value: 5, printThis: funtion() { console.log(this); }};obj.printThis(); // output : { value: 5, printThis: f }4. 기본 바인딩함수가 위의 조건 없이 호출된 경우, this는 전역 객체이며, 브라우저에서는 Window 객체다.만약 엄격모드'use strict' 일 경우, this는 전역 객체 대신 undefined가 된다.function fn() { console.log(this);}// 만약 브라우저에서 호출했을 경우fn(); // output : Window { window: Window, self: Window, ... }사실 이 규칙은 3번째 규칙과 동일하다. 차이점은 메서드로 선언되지 않은 함수는 자동으로 전역 객체인 window의 속성이 된다는 것이다.따라서 이는 암시적 매서드 호출이다. fn()을 호출하면 window.fn()으로 해석되므로 this는 window가 된다.console.log(fn === window.fn); // output : true5. 여러 규칙위의 규칙이 여러개 적용되는 경우에는 더 높은 우선순위의 규칙이 적용된다.우선순위는 new 바인딩 &gt; 명시적 바인딩 &gt; 암시적 바인딩 &gt; 기본 바인딩 순으로 이루어져 있다.const obj1 = { value: \"hi\", print: function () { console.log(this); }};const obj2 = { value: 17 };아래는 명시적 바인딩과 암시적 바인딩이 모두 적용된 예시다. 이 때는 명시적 바인딩이 우선적으로 적용된다.obj1.print.call(obj2); // output : { value: 17 }아래는 new 바인딩과 암시적 바인딩이 모두 적용된 예시다. 이 때는 new 바인딩이 우선적으로 적용된다.new obj1.print(); // output : print {}6. 화살표 함수함수가 ES2015 화살표 함수인 경우에는 위의 모든 규칙을 무시하고, 생성될 때 주변 스코프의 this 값을 받는다.const obj = { value: \"abc\", createArrowFn: function () { return () =&gt; console.log(this); }};const arrowFn = obj.createArrowFn();arrowFn(); // output : { value: 'abc', createArrowFn: f }3번째 규칙으로 돌아가서 obj.createArrowFn()을 호출하면 createArrowFn()내부의 this는 암시적으로 바인딩 되어 obj가 된다. 따라서 obj는 arrowFn의 this에 의해 바인딩된다.만약 전역 범위에서 화살표 함수를 생성한다면 this는 window가 된다." } ]
